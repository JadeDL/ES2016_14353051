# Deadlock实验报告：
## 流程：
![\[enter][1] 
![enter description here][2]
1.   把上面的代码抄到 Deadlock.java里面,保存
2.  javac Deadlock.java	
3.  lWindows系统（把下面这段到记事本里，然后保存为.bat，然将批处理文件放在java程序（Deadlock.class）目录下，双击运行，观察结果）
 ![enter description here][3]
4. 上一步的3就是让这个程序跑一百遍，通常情况下，跑个几十遍就会停的像这样：跑到第49次就停了，多少次停是随机的，调节程序中count值，使其发生死锁。
5. 截图如下:
![enter description here][4]
## 实验结果截图及分析：
1.	死锁停在第几次的截图（由下实验截图可知，死锁停在第42次）
 
2.	产生死锁的4个必要条件：=[enter description here][5]
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要述条件之一不满足，就不会发生死锁。
3. 对上述程序产生死锁的解释
线程1下，程序从main进入，遇到t.start()，运行线程2，此时已经有两个线程了；CPU分配给线程1，线程1运行至while倒计时语句，运行至该循环结束之后；线程1再执行a.methodA(b)这行语句，A成员此时调用了同步函数methodA，但仅仅是进入了该函数，该函数中的任何语句都没有执行，CPU分配给了线程2，保留现场信息等动作发生； CPU执行run函数，进而执行run函数中的b.methodB(a)语句，b请求调用a的last同步函数，但发现存在一个线程正在悬挂（正在等候执行）着a对象的另一个同步函数（methodA），所以b对象调用a的last同步函数这一步被搁置，根据CPU不空原则，CPU分配给线程1； CPU分配给线程1，线程1继续执行，它企图执行b.last，此时发现已经存在一个线程正在悬挂着b对象的另一个同步函数，所以线程1被动等候，根据CPU不空原则，CPU资源剥夺，分配给线程2；重复这个过程，陷入死锁。


  [1]: ./attachments/1.jpg
  [2]: ./attachments/2.jpg
  [3]: ./attachments/3.jpg
  [4]: ./attachments/4.jpg
  [5]: ./attachments/1.jpg
